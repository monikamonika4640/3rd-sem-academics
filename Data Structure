#include <stdio.h>
#include <string.h>
// Define a structure to represent a day
struct Day {
char name[20];
int date;
char activity[100];
};
int main() {
// Declare an array of 7 elements to represent the calendar
struct Day calendar[7];
// Initialize the calendar with sample data
strcpy(calendar[0].name, "Monday");
calendar[0].date = 1;
strcpy(calendar[0].activity, "Work from 9 AM to 5 PM");
strcpy(calendar[1].name, "Tuesday");
calendar[1].date = 2;
strcpy(calendar[1].activity, "Meeting at 10 AM");
strcpy(calendar[2].name, "Wednesday");
calendar[2].date = 3;
DS LAB (BCSL305)
Prepared by Prof. Shruthi S , Dept Of AI & DS
strcpy(calendar[2].activity, "Gym at 6 PM");
strcpy(calendar[3].name, "Thursday");
calendar[3].date = 4;
strcpy(calendar[3].activity, "Dinner with friends at 7 PM");
strcpy(calendar[4].name, "Friday");
calendar[4].date = 5;
strcpy(calendar[4].activity, "Movie night at 8 PM");
strcpy(calendar[5].name, "Saturday");
calendar[5].date = 6;
strcpy(calendar[5].activity, "Weekend getaway");
strcpy(calendar[6].name, "Sunday");
calendar[6].date = 7;
strcpy(calendar[6].activity, "Relax and recharge");
// Print the calendar
printf("Calendar for the week:\n");
for (int i = 0; i < 7; i++) {
printf("%s(Date: %d): %s\n", calendar[i].name, calendar[i].date, calendar[i].activity);
}
return 0;
}

#include <stdio.h>
#include <string.h>
struct Day {
char name[20];
int date;
char activity[100];
};
void create(struct Day calendar[7]) {
for (int i = 0; i < 7; i++) {
printf("Enter details for %s:\n", calendar[i].name);
printf("Date: ");
scanf("%d", &calendar[i].date);
printf("Activity: ");
scanf(" %[^\n]", calendar[i].activity)
void read(struct Day calendar[7]) {
FILE *file = fopen("calendar.txt", "r");
if (file == NULL) {
printf("Error opening the file.\n");
return;
}
for (int i = 0; i < 7; i++) {
fscanf(file, "%d", &calendar[i].date);
fscanf(file, " %[^\n]", calendar[i].activity);
}
fclose(file);
}
void display(struct Day calendar[7]) {
printf("Calendar for the week:\n");
for (int i = 0; i < 7; i++) {
printf("%s(Date: %d): %s\n", calendar[i].name, calendar[i].date, calendar[i].activity);
}
}
int main()
{
struct Day calendar[7];
strcpy(calendar[0].name, "Monday");
strcpy(calendar[1].name, "Tuesday");
strcpy(calendar[2].name, "Wednesday");
strcpy(calendar[3].name, "Thursday");
strcpy(calendar[4].name, "Friday");
strcpy(calendar[5].name, "Saturday");
strcpy(calendar[6].name, "Sunday");
int choice;
printf("1. Create Calendar\n");
printf("2. Read Calendar from File\n");
printf("Enter your choice: ");
scanf("%d", &choice);
switch (choice) {
case 1:
create(calendar);
break;
case 2:
read(calendar);
break;
default:
printf("Invalid choice.\n");
return 1;
}

#include<stdio.h>
void main()
{
char STR[100],PAT[100],REP[100],ans[100];
int i,j,c,m,k,flag=0;
printf("\nEnter the MAIN string: \n"); gets(STR);
printf("\nEnter a PATTERN string: \n"); gets(PAT);
printf("\nEnter a REPLACE string: \n"); gets(REP);
i = m = c = j = 0; while ( STR[c] != '\0') {
// Checking for Match
if ( STR[m]==PAT[i])
{
i++; m++;
flag=1;
if( PAT[i] == '\0')
{
//copy replace string in ans string
for(k=0; REP[k] != '\0';k++,j++)
ans[j] = REP[k];
i=0;
c=m;
}
}
else 
{
ans[j] = STR[c];
j++; c++;
m = c; i=0;
}
}
if(flag==0)
{
printf("Pattern doesn't found!!!");
}
else
{
ans[j] = '\0';
printf("\nThe RESULTANT string is:%s\n" ,ans);
}
}

#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#define max_size 5
int stack[max_size],top=-1,flag=1;
int i,temp,item,rev[max_size],num[max_size];
void push();
void pop();
void display();
void pali();
int main()
{
int choice;
printf("\n\n--------STACK OPERATIONS ------ \n");
printf("1.Push\n");
printf("2.Pop\n"); printf("3.Palindrome\n"); printf("4.Display\n"); printf("5.Exit\n");
printf(" ");
while(1)
{
printf("\nEnter your choice:\t");
scanf("%d",&choice);
switch(choice)
{
case 1: push();break;
case 2: pop();
if(flag)
printf("\nThe poped element: %d\t",item);
temp=top; break;
case 3: pali();
top=temp; break;
case 4: display(); break;
case 5: exit(0); break;
default: printf("\nInvalid choice:\n"); break;
}
}
//return 0;
}
void push() 
{
if(top==(max_size-1))
{
printf("\nStack Overflow:");
}
else
{
printf("Enter the element to be inserted:\t");
scanf("%d",&item);
top=top+1;
stack[top]=item;
}
temp=top;
}
void pop() 
{
if(top==-1)
{
printf("Stack Underflow:");
flag=0;
}
else
{
item=stack[top];
top=top-1;
}
}
void pali()
{ i=0;
if(top==-1)
{
printf("Push some elements into the stack first\n");
}
else
{
while(top!=-1)
{
rev[top]=stack[top]; pop();
}
top=temp; for(i=0;i<=temp;i++)
{
if(stack[top--]==rev[i])
{
if(i==temp)
{
printf("Palindrome\n"); return;
}
}
}
printf("Not Palindrome\n");
}
}
void display()
{
int i; top=temp;
if(top==-1)
{
printf("\nStack is Empty:");
}
else
{
printf("\nThe stack elements are:\n" );
for(i=top;i>=0;i--)
{
printf("%d\n",stack[i]);
}
}
}

#define SIZE 50 /* Size of Stack */
#include <ctype.h>
#include <stdio.h>
char s[SIZE];
int top = -1; /* Global declarations */
push(char elem) /* Function for PUSH operation */
{
s[++top] = elem;
}
char pop() /* Function for POP operation */
{
return (s[top--]);
}
int pr(char elem) /* Function for precedence */
{
switch (elem)
{
case '#': return 0;
case '(': return 1;
case '+':
case '-': return 2;
case '*': case '/':
case '%': return 3;
case '^': return 4;
}
}
void main() /* Main Program */
{
char infx[50], pofx[50], ch, elem;
int i = 0, k = 0;
printf("\n\nRead the Infix Expression ? ");
scanf("%s", infx);
push('#');
while ((ch = infx[i++]) != '\0')
{
if (ch == '(') push(ch);
else if (isalnum(ch))
pofx[k++] = ch;
else if (ch == ')')
{
while (s[top] != '(')
pofx[k++] = pop();
elem = pop(); 
}
else 
{
while (pr(s[top]) >= pr(ch))
pofx[k++] = pop();
push(ch);
}
}
while (s[top] != '#')
pofx[k++] = pop();
pofx[k] = '\0'; 
printf("\n\nGiven Infix Expn: %s Postfix Expn: %s\n", infx, pofx);
}

#include <stdio.h>
#include <math.h>
#define MAX 20
struct stack
{
int top;
float str[MAX];
}s;
char postfix[MAX];//postfix
void push(float);
float pop();
int isoperand(char);
float operate(float,float,char);
int main()
{
int i=0;
printf("Enter Expression:");
scanf("%s",postfix);
float ans,op1,op2;
while(postfix[i]!='\0')
{
if(isoperand(postfix[i]))
push(postfix[i]-48);
else
{
op1=pop();
op2=pop();
ans=operate(op1,op2,postfix[i]);
push(ans);
printf("%f %c %f = %f\n",op2,postfix[i],op1,ans);
}
i++;
}
printf("%f",s.str[s.top]);
}
int isoperand(char x)
{
if(x>='0' && x<='9')
return 1;
else return 0;
}
void push(float x)
{
if(s.top==MAX-1)
printf("Stack is full\nStack overflow\n");
else
{
s.top++;
s.str[s.top]=x;
}
}
float pop()
{
if(s.top==-1)
{
printf("Stack is emplty\nSTACK UNDERFLOW\n");
}
else
{
s.top--;
return s.str[s.top+1];
}
}
float operate(float op1,float op2,char a)
{
switch(a)
{
case '+' : return op2+op1;
case '-' : return op2-op1;
case '*' : return op2*op1;
case '/' : return op2/op1;
case '^' : return pow(op2,op1);
}
}

#include <stdio.h>
#include <conio.h>
void tower(int n, int source, int temp,int destination)
{
if(n == 0)
return;
tower(n-1, source, destination, temp);
printf("\nMove disc %d from %c to %c", n, source, destination);
tower(n-1, temp, source, destination);
}
void main()
{
int n;
printf("\nEnter the number of discs: \n");
scanf("%d", &n);
tower(n, 'A', 'B', 'C');
printf("\n\nTotal Number of moves are: %d", (int)pow(2,n)-1);
getch();
}

#include <stdio.h>
#include <conio.h>
#define SIZE 5
int CQ[SIZE];
int front=-1;
int rear=-1, ch;
int IsCQ_Full();
int IsCQ_Empty();
voidCQ_Insert(int );
void CQ_Delet();
void CQ_Display();
void main()
{
printf("1.Insert\n2.Delete\n3.Display\n4.Exit\n");
while(1)
{
int ele;
printf("Enter your choice\n");
scanf("%d",&ch);
switch(ch)
{
case 1: if(IsCQ_Full())
printf("Circular Queu Overflow\n");
else
{
printf("Enter the element to be inserted\n");
scanf("%d",&ele); CQ_Insert(ele);
}
break;
case 2: if(IsCQ_Empty())
printf("Circular Queue Underflow\n");
else
CQ_Delet();
break;
case 3: if(IsCQ_Empty())
printf("Circular Queue Underflow\n");
else
CQ_Display();
break;
case 4: exit(0);
}
}
}
void CQ_Insert(int item)
{
if(front==-1)
front++;
rear = (rear+1)%SIZE;
CQ[rear] =item;
}
void CQ_Delet()
{
int item; item=CQ[front];
printf("Deleted element is: %d",item);
front = (front+1)%SIZE;
}
void CQ_Display()
{
int i;
if(front==-1)
printf("Circular Queue is Empty\n");
else
{
printf("Elements of the circular queue are..\n");
for(i=front;i!=rear;
i=(i+1)%SIZE);
{
printf("%d\t",CQ[i]);
}
printf("%d\n",CQ[i]);
}
}
int IsCQ_Full()
{
if(front ==(rear+1)%SIZE)
return 1;
return 0;
}
int IsCQ_Empty()
{
if(front == -1)
return 1;
else if(front == rear)
{
printf("Deleted element is: %d",CQ[front]);
front=-1;
return 1;
}
return 0;
}

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct
{
int usn;
char name[20];
char branch[20];
int semester;
char phone[20];
}STUDENT;
struct node
{
int usn;
char name[20];
char branch[20];
int semester;
char phone[20];
struct node *link;
};
typedefstruct node*NODE;
NODE getnode()
{
NODE x;
x=(NODE)malloc(sizeof(struct node));
if(x==NULL)
{
printf("out of memory\n");
exit(0);
}
return x;
}
NODE insert_front(STUDENT item,NODE first)
{
NODE temp;
temp=getnode();
temp->usn=item.usn;
strcpy(temp->name,item.name);
strcpy(temp->branch,item.branch);
temp->semester=item.semester;
strcpy(temp->phone,item.phone);
temp->link=NULL;
if(first==NULL)
return temp;
temp->link=first;
return temp;
}
NODE insert_rear(STUDENT item,NODE first)
{
NODE temp,cur;
temp=getnode();
temp->usn=item.usn;
strcpy(temp->name,item.name);
strcpy(temp->branch,item.branch);
temp->semester=item.semester;
strcpy(temp->phone,item.phone);
temp->link=NULL;
if(first==NULL)
return temp;
cur=first;
while(cur->link!=NULL)
{
cur=cur->link;
}
cur->link=temp;
return first;
}
NODE delete_front(NODE first)
{
NODE temp;
if(first==NULL)
{
printf("student list is empty\n");
return NULL;
}
temp=first;
temp=temp->link;
printf("delete student record:USN=%d\n",first->usn);
free(first);
return temp;
}
NODE delete_rear(NODE first)
{
NODE cur,prev;
if(first==NULL)
{
printf("student list is empty cannot delete\n");
return first;
}
if(first->link==NULL)
{
printf("delete student record:USN=%d\n",first->usn);
free(first);
return NULL;
}
prev=NULL;
cur=first;
while(cur->link!=NULL)
{
prev=cur;
cur=cur->link;
}
printf("delete student record:USN=%d\n",cur->usn);
free(cur);
prev->link=NULL;
return first;
}
void display(NODE first)
{
NODE cur;
int count=0;
if(first==NULL)
{
printf("student list is empty\n");
return;
}
cur=first;
while(cur!=NULL)
{
printf("%d\t%s\t%s\t%d\t%s\t\n",cur->usn,cur->name,cur->branch,cur->semester,cur->phone);
cur=cur->link;
count++;
}
printf("numbrt of students=%d\n",count);
}
void main()
{
NODE first;
int choice;
STUDENT item;
first=NULL;
for(;;)
{
printf("1.insert_front\n2.insert_rear\n3.delete_front\n4.delete_rear\n5.display\n6.exit\n");
printf("Enter the choice\n");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("USN :\n");
scanf("%d",&item.usn);
printf("name :\n");
scanf("%s",item.name);
printf("branch :\n");
scanf("%s",item.branch);
printf("semester:\n");
scanf("%d",&item.semester);
printf("phone :\n");
scanf("%s",item.phone);
first=insert_front(item,first);
break;
case 2:
printf("USN :\n");
scanf("%d",&item.usn);
printf("name :\n");
scanf("%s",item.name);
printf("branch :\n");
scanf("%s",item.branch);
printf("semester:\n");
scanf("%d",&item.semester);
printf("phone :\n");
scanf("%s",item.phone);
first=insert_rear(item,first);
break;
case 3:
first=delete_front(first);
break;
case 4:
first=delete_rear(first);
break;
case 5:
display(first);
break;
default:
exit(0);
}
}
}

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct
{
int usn;
char name[20];
char branch[20];
int semester;
char phone[20];
}STUDENT;
struct node
{
int usn;
char name[20];
char branch[20];
int semester;
char phone[20];
struct node *link;
};
typedefstruct node*NODE;
NODE getnode()
{
NODE x;
x=(NODE)malloc(sizeof(struct node));
if(x==NULL)
{
printf("out of memory\n");
exit(0);
}
return x;
}
NODE insert_front(STUDENT item,NODE first)
{
NODE temp;
temp=getnode();
temp->usn=item.usn;
strcpy(temp->name,item.name);
strcpy(temp->branch,item.branch);
temp->semester=item.semester;
strcpy(temp->phone,item.phone);
temp->link=NULL;
if(first==NULL)
return temp;
temp->link=first;
return temp;
}
NODE insert_rear(STUDENT item,NODE first)
{
NODE temp,cur;
temp=getnode();
temp->usn=item.usn;
strcpy(temp->name,item.name);
strcpy(temp->branch,item.branch);
temp->semester=item.semester;
strcpy(temp->phone,item.phone);
temp->link=NULL;
if(first==NULL)
return temp;
cur=first;
while(cur->link!=NULL)
{
cur=cur->link;
}
cur->link=temp;
return first;
}
NODE delete_front(NODE first)
{
NODE temp;
if(first==NULL)
{
printf("student list is empty\n");
return NULL;
}
temp=first;
temp=temp->link;
printf("delete student record:USN=%d\n",first->usn);
free(first);
return temp;
}
NODE delete_rear(NODE first)
{
NODE cur,prev;
if(first==NULL)
{
printf("student list is empty cannot delete\n");
return first;
}
if(first->link==NULL)
{
printf("delete student record:USN=%d\n",first->usn);
free(first);
return NULL;
}
prev=NULL;
cur=first;
while(cur->link!=NULL)
{
prev=cur;
cur=cur->link;
}
printf("delete student record:USN=%d\n",cur->usn);
free(cur);
prev->link=NULL;
return first;
}
void display(NODE first)
{
NODE cur;
int count=0;
if(first==NULL)
{
printf("student list is empty\n");
return;
}
cur=first;
while(cur!=NULL)
{
printf("%d\t%s\t%s\t%d\t%s\t\n",cur->usn,cur->name,cur->branch,cur->semester,cur->phone);
cur=cur->link;
count++;
}
printf("numbrt of students=%d\n",count);
}
void main()
{
NODE first;
int choice;
STUDENT item;
first=NULL;
for(;;)
{
printf("1.insert_front\n2.insert_rear\n3.delete_front\n4.delete_rear\n5.display\n6.exit\n");
printf("Enter the choice\n");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("USN :\n");
scanf("%d",&item.usn);
printf("name :\n");
scanf("%s",item.name);
printf("branch :\n");
scanf("%s",item.branch);
printf("semester:\n");
scanf("%d",&item.semester);
printf("phone :\n");
scanf("%s",item.phone);
first=insert_front(item,first);
break;
case 2:
printf("USN :\n");
scanf("%d",&item.usn);
printf("name :\n");
scanf("%s",item.name);
printf("branch :\n");
scanf("%s",item.branch);
printf("semester:\n");
scanf("%d",&item.semester);
printf("phone :\n");
scanf("%s",item.phone);
first=insert_rear(item,first);
break;
case 3:
first=delete_front(first);
break;
case 4:
first=delete_rear(first);
break;
case 5:
display(first);
break;
default:
exit(0);
}
}
}



